"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _last2 = _interopRequireDefault(require("lodash/last"));

var _split2 = _interopRequireDefault(require("lodash/split"));

var _trim2 = _interopRequireDefault(require("lodash/trim"));

var _set2 = _interopRequireDefault(require("lodash/set"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _isNull2 = _interopRequireDefault(require("lodash/isNull"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _max2 = _interopRequireDefault(require("lodash/max"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _trimStart2 = _interopRequireDefault(require("lodash/trimStart"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _each2 = _interopRequireDefault(require("lodash/each"));

var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));

var _transform2 = _interopRequireDefault(require("lodash/transform"));

var _merge2 = _interopRequireDefault(require("lodash/merge"));

var _mobx = require("mobx");

var _utils = _interopRequireDefault(require("../utils"));

var _parser = _interopRequireDefault(require("../parser"));

var _Initializer2 = _interopRequireDefault(require("./Initializer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
  Field Actions
*/
var Actions = /*#__PURE__*/function (_Initializer) {
  _inherits(Actions, _Initializer);

  var _super = _createSuper(Actions);

  function Actions() {
    var _this;

    _classCallCheck(this, Actions);

    _this = _super.call(this);
    (0, _mobx.makeObservable)(_assertThisInitialized(_this), {
      submit: _mobx.action,
      deepUpdate: _mobx.action,
      set: _mobx.action,
      add: _mobx.action,
      del: _mobx.action
    });
    return _this;
  }

  _createClass(Actions, [{
    key: "validate",
    value: function validate() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var $opt = (0, _merge2["default"])(opt, {
        path: this.path
      });
      return this.state.form.validator.validate($opt, obj);
    }
    /**
      Submit
    */

  }, {
    key: "submit",
    value: function submit() {
      var _this2 = this;

      var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.$submitting = true;
      this.$submitted += 1;

      var exec = function exec(isValid) {
        return isValid ? _this2.execHook('onSuccess', o) : _this2.execHook('onError', o);
      };

      var validate = function validate() {
        return _this2.validate({
          showErrors: _this2.state.options.get('showErrorsOnSubmit', _this2)
        }).then(function (_ref) {
          var isValid = _ref.isValid;
          var handler = exec(isValid);
          if (isValid) return handler;

          var $err = _this2.state.options.get('defaultGenericError', _this2);

          var $throw = _this2.state.options.get('submitThrowsError', _this2);

          if ($throw && $err) _this2.invalidate();
          return handler;
        }) // eslint-disable-next-line
        .then((0, _mobx.action)(function () {
          return _this2.$submitting = false;
        }))["catch"]((0, _mobx.action)(function (err) {
          _this2.$submitting = false;
          throw err;
        })).then(function () {
          return _this2;
        });
      };

      return _utils["default"].isPromise(exec) ? exec.then(function () {
        return validate();
      }) : validate();
    }
    /**
     Check Field Computed Values
     */

  }, {
    key: "check",
    value: function check(prop) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _utils["default"].allowedProps('booleans', [prop]);

      return deep ? _utils["default"].checkPropType({
        type: _utils["default"].props.types[prop],
        data: this.deepCheck(_utils["default"].props.types[prop], prop, this.fields)
      }) : this[prop];
    }
  }, {
    key: "deepCheck",
    value: function deepCheck(type, prop, fields) {
      var _this3 = this;

      var $fields = _utils["default"].getObservableMapValues(fields);

      return (0, _transform2["default"])($fields, function (check, field) {
        if (!field.fields.size || _utils["default"].props.exceptions.includes(prop)) {
          check.push(field[prop]);
        }

        var $deep = _this3.deepCheck(type, prop, field.fields);

        check.push(_utils["default"].checkPropType({
          type: type,
          data: $deep
        }));
        return check;
      }, []);
    }
    /**
     Update Field Values recurisvely
     OR Create Field if 'undefined'
     */

  }, {
    key: "update",
    value: function update(fields) {
      if (!(0, _isPlainObject2["default"])(fields)) {
        throw new Error('The update() method accepts only plain objects.');
      }

      return this.deepUpdate(_parser["default"].prepareFieldsData({
        fields: fields
      }));
    }
  }, {
    key: "deepUpdate",
    value: function deepUpdate(fields) {
      var _this4 = this;

      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var recursion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      (0, _each2["default"])(fields, function (field, key) {
        var $key = (0, _has2["default"])(field, 'name') ? field.name : key;
        var $path = (0, _trimStart2["default"])("".concat(path, ".").concat($key), '.');

        var $field = _this4.select($path, null, false);

        var $container = _this4.select(path, null, false) || _this4.state.form.select(_this4.path, null, false);

        if (!(0, _isNil2["default"])($field) && !(0, _isUndefined2["default"])(field)) {
          if ((0, _isArray2["default"])($field.values())) {
            var n = (0, _max2["default"])((0, _map2["default"])(field.fields, function (f, i) {
              return Number(i);
            }));
            if (n === undefined) n = -1; // field's value is []

            (0, _each2["default"])(_utils["default"].getObservableMapValues($field.fields), function ($f) {
              if (Number($f.name) > n) $field.fields["delete"]($f.name);
            });
          }

          if ((0, _isNull2["default"])(field) || (0, _isNil2["default"])(field.fields)) {
            $field.$value = _parser["default"].parseInput($field.$input, {
              separated: field
            });
            return;
          }
        }

        if (!(0, _isNil2["default"])($container) && (0, _isNil2["default"])($field)) {
          // get full path when using update() with select() - FIX: #179
          var $newFieldPath = (0, _trimStart2["default"])([_this4.path, $path].join('.'), '.'); // init field into the container field

          $container.initField($key, $newFieldPath, field, true);
        } else if (recursion) {
          if ((0, _has2["default"])(field, 'fields') && !(0, _isNil2["default"])(field.fields)) {
            // handle nested fields if defined
            _this4.deepUpdate(field.fields, $path);
          } else {
            // handle nested fields if undefined or null
            var $fields = _parser["default"].pathToFieldsTree(_this4.state.struct(), $path);

            _this4.deepUpdate($fields, $path, false);
          }
        }
      });
    }
    /**
      Get Fields Props
     */

  }, {
    key: "get",
    value: function get() {
      var prop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if ((0, _isNil2["default"])(prop)) {
        return this.deepGet([].concat(_toConsumableArray(_utils["default"].props.booleans), _toConsumableArray(_utils["default"].props.field), _toConsumableArray(_utils["default"].props.validation)), this.fields);
      }

      _utils["default"].allowedProps('all', (0, _isArray2["default"])(prop) ? prop : [prop]);

      if ((0, _isString2["default"])(prop)) {
        if (strict && this.fields.size === 0) {
          return _parser["default"].parseCheckOutput(this, prop);
        }

        var value = this.deepGet(prop, this.fields);
        return _parser["default"].parseCheckArray(this, value, prop);
      }

      return this.deepGet(prop, this.fields);
    }
    /**
      Get Fields Props Recursively
     */

  }, {
    key: "deepGet",
    value: function deepGet(prop, fields) {
      var _this5 = this;

      return (0, _transform2["default"])(_utils["default"].getObservableMapValues(fields), function (obj, field) {
        var $nested = function $nested($fields) {
          return $fields.size !== 0 ? _this5.deepGet(prop, $fields) : undefined;
        };

        Object.assign(obj, _defineProperty({}, field.key, {
          fields: $nested(field.fields)
        }));

        if ((0, _isString2["default"])(prop)) {
          var removeValue = prop === 'value' && (_this5.state.options.get('retrieveOnlyDirtyValues', _this5) && field.isPristine || _this5.state.options.get('retrieveOnlyEnabledFields', _this5) && field.disabled || _this5.state.options.get('softDelete', _this5) && field.deleted);

          if (field.fields.size === 0) {
            delete obj[field.key]; // eslint-disable-line

            if (removeValue) return obj;
            return Object.assign(obj, _defineProperty({}, field.key, _parser["default"].parseCheckOutput(field, prop)));
          }

          var value = _this5.deepGet(prop, field.fields);

          if (prop === 'value') value = field.$output(value);
          delete obj[field.key]; // eslint-disable-line

          if (removeValue) return obj;
          return Object.assign(obj, _defineProperty({}, field.key, _parser["default"].parseCheckArray(field, value, prop)));
        }

        (0, _each2["default"])(prop, function ($prop) {
          return Object.assign(obj[field.key], _defineProperty({}, $prop, field[$prop]));
        });
        return obj;
      }, {});
    }
    /**
     Set Fields Props
     */

  }, {
    key: "set",
    value: function set(prop, data) {
      // UPDATE CUSTOM PROP
      if ((0, _isString2["default"])(prop) && !(0, _isUndefined2["default"])(data)) {
        _utils["default"].allowedProps('field', [prop]);

        var deep = (0, _isObject2["default"])(data) && prop === 'value' || (0, _isPlainObject2["default"])(data);
        if (deep && this.hasNestedFields) this.deepSet(prop, data, '', true);else (0, _set2["default"])(this, "$".concat(prop), data);
        return;
      } // NO PROP NAME PROVIDED ("prop" is value)


      if ((0, _isNil2["default"])(data)) {
        if (this.hasNestedFields) this.deepSet('value', prop, '', true);else this.set('value', prop);
      }
    }
    /**
      Set Fields Props Recursively
     */

  }, {
    key: "deepSet",
    value: function deepSet($, data) {
      var _this6 = this;

      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var recursion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var err = 'You are updating a not existent field:';
      var isStrict = this.state.options.get('strictUpdate', this);

      if ((0, _isNil2["default"])(data)) {
        this.each(function (field) {
          return field.clear(true);
        });
        return;
      }

      (0, _each2["default"])(data, function ($val, $key) {
        var $path = (0, _trimStart2["default"])("".concat(path, ".").concat($key), '.'); // get the field by path joining keys recursively

        var field = _this6.select($path, null, isStrict); // if no field found when is strict update, throw error


        if (isStrict) _utils["default"].throwError($path, field, err); // update the field/fields if defined

        if (!(0, _isUndefined2["default"])(field)) {
          // update field values or others props
          if (!(0, _isUndefined2["default"])($val)) {
            field.set($, $val, recursion);
          } // update values recursively only if field has nested


          if (field.fields.size && (0, _isObject2["default"])($val)) {
            _this6.deepSet($, $val, $path, recursion);
          }
        }
      });
    }
    /**
     Add Field
     */

  }, {
    key: "add",
    value: function add(obj) {
      var _this7 = this;

      if (_utils["default"].isArrayOfObjects(obj)) {
        return (0, _each2["default"])(obj, function (values) {
          return _this7.update(_defineProperty({}, _utils["default"].maxKey(_this7.fields), values));
        });
      }

      var key; // eslint-disable-next-line

      if ((0, _has2["default"])(obj, 'key')) key = obj.key;
      if ((0, _has2["default"])(obj, 'name')) key = obj.name;
      if (!key) key = _utils["default"].maxKey(this.fields);

      var $path = function $path($key) {
        return (0, _trimStart2["default"])([_this7.path, $key].join('.'), '.');
      };

      var tree = _parser["default"].pathToFieldsTree(this.state.struct(), this.path, 0, true);

      return this.initField(key, $path(key), (0, _merge2["default"])(tree[0], obj));
    }
    /**
     Del Field
     */

  }, {
    key: "del",
    value: function del() {
      var $path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var isStrict = this.state.options.get('strictDelete', this);

      var path = _parser["default"].parsePath(_utils["default"].$try($path, this.path));

      var fullpath = (0, _trim2["default"])([this.path, path].join('.'), '.');
      var container = this.container($path);
      var keys = (0, _split2["default"])(path, '.');
      var last = (0, _last2["default"])(keys);

      if (isStrict && !container.fields.has(last)) {
        var msg = "Key \"".concat(last, "\" not found when trying to delete field");

        _utils["default"].throwError(fullpath, null, msg);
      }

      if (this.state.options.get('softDelete', this)) {
        return this.select(fullpath).set('deleted', true);
      }

      return container.fields["delete"](last);
    }
  }]);

  return Actions;
}(_Initializer2["default"]);

exports["default"] = Actions;
;
module.exports = exports["default"];